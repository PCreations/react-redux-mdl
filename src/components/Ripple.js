import React from 'react'
import createFragment from 'react-addons-create-fragment'
import classNames from 'classnames'
import PureRenderMixin from 'react-addons-pure-render-mixin';


const INITIAL_SCALE = 'scale(0.0001, 0.0001)'
const INITIAL_SIZE = '1px'
const INITIAL_OPACITY = '0.4'
const FINAL_OPACITIY = '0'
const FINAL_SCALE = ''

const cssClasses = {
    RIPPLE_CONTAINER: 'mdl-button__ripple-container',
    RIPPLE: 'mdl-ripple',
    RIPPLE_CENTER: 'mdl-ripple--center',
    RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
    RIPPLE: 'mdl-ripple',
    IS_ANIMATING: 'is-animating',
    IS_VISIBLE: 'is-visible'
}


class RippleContainer extends React.Component {
    constructor(props) {
        super(props)
        this.displayName = 'RippleContainer'
        this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);
    }

    render() {

        let rippleClassNames = {
            [cssClasses.RIPPLE]: true,
            ...this.props.rippleClassNames
        }

        return (
            <span className={cssClasses.RIPPLE_CONTAINER}>
                <span
                    className={classNames(rippleClassNames)}
                    style={this.props.rippleStyle}
                    ref={ref => this.props.setRippleElement(ref)}></span>
            </span>
        )
    }

}

RippleContainer.propTypes = {
    setRippleElement: React.PropTypes.func.isRequired,
    rippleClassNames: React.PropTypes.object.isRequired,
    rippleStyle: React.PropTypes.object.isRequired
}


class RippleEffect extends React.Component {
    constructor(props) {
        super(props)
        this.displayName = 'RippleEffect'
        this.element_ = null
        this.rippleElement_ = null
        this.state = {
            frameCount: 0,
            ignoringMouseDown: false,
            x: 0,
            y: 0,
            boundHeight: 0,
            boundWidth: 0,
            rippleElementStyle: {},
            rippleClasses: {}
        }
        this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);
    }

    downHandler(event) {
        let state = {
            ...this.state
        }

        if (!state.rippleElementStyle.width && !state.rippleElementStyle.height) {
            const rect = this.element_.getBoundingClientRect();
            const rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2
            state = {
                ...state,
                boundHeight: rect.height,
                boundWidth: rect.width,
                rippleElementStyle: {
                    ...state.rippleElementStyle,
                    width: `${rippleSize}px`,
                    height: `${rippleSize}px`,
                }
            }
        }

        state.rippleClasses = {
            ...state.rippleClasses,
            [cssClasses.IS_VISIBLE]: true
        }

        if (event.type === 'mousedown' && state.ignoringMouseDown) {
            state.ignoringMouseDown = false
        } else {
            if (event.type === 'touchstart') {
                state.ignoringMouseDown = true
            }
            if (state.frameCount > 0) {
                return
            }
            state.frameCount = 1
            const bound = event.currentTarget.getBoundingClientRect()
            let x,y
            // Check if we are handling a keyboard click.
            if (event.clientX === 0 && event.clientY === 0) {
                x = Math.round(bound.width / 2);
                y = Math.round(bound.height / 2);
            } else {
                var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
                var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
                x = Math.round(clientX - bound.left);
                y = Math.round(clientY - bound.top);
            }
            state.x = x,
            state.y = y
            state = this.setRippleStyles(state, true)
            this.setState(state, () => requestAnimationFrame(this.animFrameHandler.bind(this)))
        }
    }

    upHandler(event) {
        // Don't fire for the artificial "mouseup" generated by a double-click.
        if (event && event.detail !== 2) {
            this.setState((state, props) => {
                const { [cssClasses.IS_VISIBLE]: isVisible, ...rippleClasses } = state.rippleClasses
                return { rippleClasses }
            })
        }
        this.element_.blur()
    }

    animFrameHandler() {
        if (this.state.frameCount > 0) {
            this.setState((state, props) => {
                return {
                    frameCount: state.frameCount - 1
                }
            }, () => requestAnimationFrame(this.animFrameHandler.bind(this)))
        } else {
            this.setState((state, props) =>this.setRippleStyles({ ...state }, false))
        }
    }

    setRippleStyles(state, start) {
        const recentering = this.element_.classList.contains(cssClasses.RIPPLE_CENTER)
        if (this.rippleElement_ !== null) {
            let transformString, scale
            let { [cssClasses.IS_ANIMATING]: isAnimating, ...rippleClasses } = state.rippleClasses
            rippleClasses = start ? rippleClasses : {
                ...state.rippleClasses,
                [cssClasses.IS_ANIMATING]: true
            }
            let offset = `translate(${state.x}px,${state.y}px)`

            if (start) {
                scale = INITIAL_SCALE;
            } else {
                scale = FINAL_SCALE;
                if (recentering) {
                    offset = `translate(${state.boundWidth / 2}px, ${state.boundHeight / 2}px)`
                }
            }

            transformString = `translate(-50%, -50%) ${offset} ${scale}`

            return {
                ...state,
                rippleElementStyle: {
                    ...state.rippleElementStyle,
                    WebkitTransform: transformString,
                    MsTransform: transformString,
                    transform: transformString
                },
                rippleClasses
            }
        }
    }

    componentDidMount() {
        if (this.element_ && !this.element_.classList.contains(cssClasses.RIPPLE_EFFECT_IGNORE_EVENTS)) {
            this.element_.addEventListener('mousedown', this.downHandler.bind(this))
            this.element_.addEventListener('touchstart', this.downHandler.bind(this))
            this.element_.addEventListener('mouseup', this.upHandler.bind(this))
            this.element_.addEventListener('mouseleave', this.upHandler.bind(this))
            this.element_.addEventListener('touchend', this.upHandler.bind(this))
            this.element_.addEventListener('blur', this.upHandler.bind(this))
        }
    }

    wrappedChildren() {
        let childrensChildFragment = createFragment({
            children: this.props.children.props.children,
            rippleContainer: (
                <RippleContainer
                    rippleClassNames={this.state.rippleClasses}
                    rippleStyle={this.state.rippleElementStyle}
                    setRippleElement={ref => this.rippleElement_ = ref}/>
            )
        })

        return React.cloneElement(
            this.props.children,
            {
                ...this.props.children.props,
                children: childrensChildFragment
            }
        )
    }

    render() {
        return (
            <span ref={ref => this.element_ = ref && ref.firstChild}>{this.wrappedChildren()}</span>
        )
    }
}

RippleEffect.propTypes = {
    children: React.PropTypes.element.isRequired
}


export default RippleEffect;
